Αρχικά ο χρήστης δίνει μια γραμμή (line) και την χωρίζει σε λέξεις(tokens).
Για τον σωστό χωρισμό των λέξεων πρέπει ο χρήστης πρέπει να δώσει μια εντολή με κενά ανάμεσα σε κάθε λέξη ή
σύμβολο ανακατεύθυνσης ή pipe. Πχ. Cat text.txt | sort > out.txt
Η εργασία χωρίζεται σε 4 αρχεία .c και 3 .h, τα οποία είναι το mysh.c όπου είναι το βασικό, το pipes.c με το pipes.h,
το alias.c με το alias.h και το history.c με το history.h. Για το compile της άσκησης χρησιμοποιώ το Makefile όπου έχω τα
αντικείμενα mysh.o history.o alias.o pipes.o και το όνομα mysh για να εκτελεστεί η εντολή gcc -o mysh mysh.c pipes.c alias.c history.c.

Για την υποστήριξη ανακατευθύνσεων έχω συγκεκριμένα flags για την είσοδο, την έξοδο και την ανακατεύθυνση
προσθήκης όπου γίνονται 1 όταν βρεθεί κάποιο από αυτά. Επίσης αποθηκεύω παράλληλα το όνομα του αρχείου εισόδου
ή εξόδου αντίστοιχα και τέλος αποθηκεύω στον πίνακα args_array τα tokens χωρίς τα σύμβολο ανακατεύθυνσης.

Για την υποστήριξη pipes, έχω πάλι ένα flag που μου δείχνει αν έχω pipes στην εντολή μου ή όχι. Επίσης έχω ένα
δεύτερο πίνακα τον args_pipe_array όπου αποθηκεύω το δεξί μέρος του pipe. Στην συνέχεια αφού τελειώσω με τον έλεγχο,
έχω ξεχωριστό αρχείο για την υλοποίηση των pipes στο οποίο καλώ τη fork() και αν είμαι στην διεργασία παιδί καλώ την
execvp για να τρέξω το δεξί κομμάτι του pipe. Αν είμαι στη διεργασία γονιός τρέχω το αριστερό κομμάτι δηλαδή το args_array.
Επειδή χρησιμοποιώ pipe_files θα τρέξει πρώτα ο γονιός επειδη πρώτα πρέπει να γράψει και μετά να διαβάσει το παιδί.

Για την υποστήριξη aliases ελέγχω αν η εντολή που έδωσε ο χρήστης είναι κάποιο alias για να την αντικαταστήσω.
Για την δημιουργία alias αρχικά έχω έναν βοηθητικό πίνακα τον alias_list ο οποίος έχει τα tokens που χρειάζονται
για το command του alias, έτσι ώστε να αντιγραφεί στο command. Αν ο χρήστης δημιουργήσει ένα alias με υπάρχον όνομα
τότε διαγράφεται το προηγούμενο και ανανεώνεται το struct. Στην συνάρτηση destroyalias πρώτα μετακινώ μια θέση πίσω
τα alias που βρίσκονται μετά από αυτό που θα καταστρέψω και ελευθερώνω τη μνήμη του τελευταίου.

Για την υποστήριξη history έχω ένα struct όπου αποθηκεύω την κάθε εντολή με το αντίστοιχο id της, δηλαδή την θέση.
Χρησιμοποιώ 3 συναρτήσεις την print_history() για να εκτυπώσει όλο το  struct history, την find_history() για να
αντικαταστήσει την εντολή που θέλει ο χρήστης από τον πίνακα και την add_history() για να προσθέσει struct, δηλαδή
την καινούρια εντολή που θα δώσει ο χρήστης.

Στην main έχω ένα while loop που σταματά όταν του δοθεί η εντολή "exit". Μετά τους διάφορους ελέγχους για ανακατευθύνσεις
κτλ, κάνω fork() όπου στην διεργασία παιδί καλώ την συνάρτηση pipe_function() αν χρειάζεται, αλλιώς κάνει τις ανακατευθύνσεις
που χρειάζονται με τη χρήση της συνάρτησης dup2 και καλέι την execvp για να τρέξει την εντολή. Διαφορετικά στην διεργασία
γονιός περιμένει το παιδί να τελειώσει για να εκτυπώσει success ή fail σε περίπτωση επιτυχίας ή λάθους.

